from collections import deque

def flood_fill(grid, x, y, color):
 """
 Preenche a região conectada à célula inicial (x, y) com a cor fornecida.
 Utiliza uma abordagem de BFS para explorar as células conectadas.
 """
 n = len(grid)
 m = len(grid[0])

 # Verifica se a célula inicial é válida para preenchimento
 if not (0 <= x < n and 0 <= y < m):
     raise ValueError("As coordenadas iniciais estão fora dos limites do grid.")
 if grid[x][y] != 0:
     return

 # Direções ortogonais: cima, baixo, esquerda, direita
 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

 # Fila para BFS
 queue = deque([(x, y)])
 grid[x][y] = color  # Preenche a célula inicial com a nova cor

 while queue:
     cx, cy = queue.popleft()

     for dx, dy in directions:
         nx, ny = cx + dx, cy + dy

         # Verifica se a célula vizinha está dentro dos limites e é navegável (valor 0)
         if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:
             grid[nx][ny] = color  # Preenche a célula vizinha
             queue.append((nx, ny))  # Adiciona a célula vizinha à fila

             from collections import deque

def flood_fill(grid, x, y, color):
    """
    Preenche a região conectada à célula inicial (x, y) com a cor fornecida.
    Utiliza uma abordagem de BFS para explorar as células conectadas.
    """
    n = len(grid)
    m = len(grid[0])

    # Verifica se a célula inicial é válida para preenchimento
    if not (0 <= x < n and 0 <= y < m):
        raise ValueError("As coordenadas iniciais estão fora dos limites do grid.")
    if grid[x][y] != 0:
        return

    # Direções ortogonais: cima, baixo, esquerda, direita
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    # Fila para BFS
    queue = deque([(x, y)])
    grid[x][y] = color  # Preenche a célula inicial com a nova cor

    while queue:
        cx, cy = queue.popleft()

        for dx, dy in directions:
            nx, ny = cx + dx, cy + dy

            # Verifica se a célula vizinha está dentro dos limites e é navegável (valor 0)
            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:
                grid[nx][ny] = color  # Preenche a célula vizinha
                queue.append((nx, ny))  # Adiciona a célula vizinha à fila

def find_next_start(grid):
    """
    Encontra a próxima célula navegável (com valor 0) no grid.
    Retorna as coordenadas da célula ou None se não houver mais células navegáveis.
    """
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 0:
                return i, j
    return None
def map_terrain(grid):
    """
    Mapeia todo o terreno, identificando e preenchendo automaticamente todas as regiões conectadas.
    Cada região recebe uma cor única (incremental).
    """
    n = len(grid)
    m = len(grid[0])
    current_color = 2  # Começa com a cor 2 para a primeira região

    while True:
        # Encontra a próxima célula navegável
        start = find_next_start(grid)
        if not start:
            break  # Não há mais células navegáveis

        x, y = start
        flood_fill(grid, x, y, current_color)
        current_color += 1  # Incrementa a cor para a próxima região

    return grid

# Entrada do usuário
if __name__ == "__main__":
    # Dimensões do grid
    while True:
        try:
            n, m = map(int, input("Digite as dimensões do grid (coluna linha): ").split())
            break
        except ValueError:
            print("Entrada inválida! Certifique-se de digitar dois números inteiros separados por espaço.")

    # Leitura do grid
    print("Digite o grid linha por linha (valores separados por espaço):")
    grid = []
    for _ in range(n):
        while True:
            try:
                row = list(map(int, input().split()))
                if len(row) != m:
                    raise ValueError("O número de colunas não corresponde ao especificado.")
                grid.append(row)
                break
            except ValueError as e:
                print(f"Erro: {e}. Tente novamente.")

    # Coordenadas iniciais
    while True:
        try:
            x, y = map(int, input("Digite as coordenadas iniciais (x y): ").split())
            if not (0 <= x < n and 0 <= y < m):
                raise ValueError("As coordenadas estão fora dos limites do grid.")
            break
        except ValueError as e:
            print(f"Erro: {e}. Tente novamente.")

    # Mapeamento do terreno
    updated_grid = map_terrain(grid)

    # Saída do grid atualizado
    print("Grid atualizado:")
    for row in updated_grid:
        print(" ".join(map(str, row)))